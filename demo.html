<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>corneliuscornelius - Asset Demo</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #050508;
      color: #888;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      min-height: 100vh;
      position: relative;
    }

    #death-of-life {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      pointer-events: none;
    }

    body > *:not(#death-of-life) {
      position: relative;
      z-index: 1;
    }

    h1 {
      text-align: center;
      padding: 2rem;
      color: #3d1515;
      font-size: 2.5rem;
      text-transform: lowercase;
      letter-spacing: 0.2em;
    }

    h2 {
      color: #5c1e1e;
      padding: 1rem 2rem;
      font-size: 1.2rem;
      border-bottom: 1px solid #1a1a1a;
    }

    .scene {
      position: relative;
      width: 100%;
      max-width: 1200px;
      margin: 2rem auto;
      aspect-ratio: 16/9;
      overflow: hidden;
      border: 2px solid #1a1a1a;
      border-radius: 4px;
    }

    .scene img.bg {
      position: absolute;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .scene .character {
      position: absolute;
      height: 30%;
      filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.8));
    }

    .scene .prop {
      position: absolute;
      filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.8));
    }

    /* Animation keyframes */
    @keyframes fall {
      0% { transform: translateY(-100%) rotate(0deg); }
      100% { transform: translateY(200%) rotate(45deg); }
    }

    @keyframes float {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    @keyframes flicker {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.8; transform: scale(0.95); }
    }

    @keyframes catapult-arm {
      0%, 80% { transform: rotate(-15deg); }
      85% { transform: rotate(-60deg); }
      100% { transform: rotate(-15deg); }
    }

    @keyframes fly {
      0% { transform: translateX(0) translateY(0); opacity: 1; }
      100% { transform: translateX(400px) translateY(-200px); opacity: 0; }
    }

    /* Scene 1: Siege */
    #scene1 .stickman {
      bottom: 22%;
      left: 15%;
      animation: float 2s ease-in-out infinite;
    }

    #scene1 .catapult {
      bottom: 18%;
      right: 10%;
      height: 20%;
    }

    #scene1 .boulder {
      bottom: 35%;
      right: 18%;
      height: 8%;
      animation: fly 3s ease-in infinite;
    }

    #scene1 .fire {
      bottom: 45%;
      left: 42%;
      height: 15%;
      animation: flicker 0.3s ease-in-out infinite;
    }

    /* Scene 2: Throne Room */
    #scene2 .king {
      bottom: 32%;
      left: 47%;
      height: 25%;
    }

    #scene2 .crown {
      bottom: 54%;
      left: 49%;
      height: 6%;
      animation: float 3s ease-in-out infinite;
    }

    #scene2 .falling-guy {
      top: 10%;
      right: 25%;
      height: 25%;
      animation: fall 4s linear infinite;
    }

    #scene2 .sword {
      bottom: 25%;
      right: 30%;
      height: 15%;
      transform: rotate(45deg);
    }

    /* Scene 3: Aftermath */
    #scene3 .dead {
      bottom: 20%;
      left: 20%;
      width: 30%;
      height: auto;
    }

    #scene3 .tombstone {
      bottom: 18%;
      right: 25%;
      height: 25%;
    }

    #scene3 .debris {
      bottom: 15%;
      left: 50%;
      transform: translateX(-50%);
      width: 25%;
      height: auto;
    }

    /* Asset grid */
    .asset-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 1rem;
      padding: 2rem;
      max-width: 1200px;
      margin: 0 auto;
    }

    .asset-card {
      background: #121218;
      border: 1px solid #1a1a1a;
      border-radius: 4px;
      padding: 1rem;
      text-align: center;
    }

    .asset-card img {
      max-width: 100%;
      max-height: 120px;
      margin-bottom: 0.5rem;
    }

    .asset-card p {
      font-size: 0.8rem;
      color: #555;
    }

    footer {
      text-align: center;
      padding: 3rem;
      color: #333;
      font-size: 0.9rem;
    }

    footer a {
      color: #5c1e1e;
    }
  </style>
</head>
<body>
  <h1>corneliuscornelius</h1>

  <h2>Scene 1: The Siege</h2>
  <div class="scene" id="scene1">
    <img class="bg" src="assets/backgrounds/castle-siege.svg" alt="Castle siege background">
    <img class="character stickman" src="assets/characters/stickman-base.svg" alt="Stick figure">
    <img class="prop catapult" src="assets/props/catapult.svg" alt="Catapult">
    <img class="prop boulder" src="assets/props/boulder.svg" alt="Boulder">
    <img class="prop fire" src="assets/props/fire.svg" alt="Fire">
  </div>

  <h2>Scene 2: The Throne Room</h2>
  <div class="scene" id="scene2">
    <img class="bg" src="assets/backgrounds/castle-interior.svg" alt="Castle interior">
    <img class="character king" src="assets/characters/stickman-base.svg" alt="King">
    <img class="prop crown" src="assets/props/crown.svg" alt="Crown">
    <img class="character falling-guy" src="assets/characters/stickman-falling.svg" alt="Falling">
    <img class="prop sword" src="assets/props/sword.svg" alt="Sword">
  </div>

  <h2>Scene 3: The Aftermath</h2>
  <div class="scene" id="scene3">
    <img class="bg" src="assets/backgrounds/night-sky-simple.svg" alt="Night sky">
    <img class="character dead" src="assets/characters/stickman-dead.svg" alt="Dead stick figure">
    <img class="prop tombstone" src="assets/props/tombstone.svg" alt="Tombstone">
    <img class="prop debris" src="assets/props/debris-pile.svg" alt="Debris">
  </div>

  <h2>All Assets</h2>
  <div class="asset-grid">
    <div class="asset-card">
      <img src="assets/characters/stickman-base.svg" alt="Base">
      <p>stickman-base</p>
    </div>
    <div class="asset-card">
      <img src="assets/characters/stickman-falling.svg" alt="Falling">
      <p>stickman-falling</p>
    </div>
    <div class="asset-card">
      <img src="assets/characters/stickman-dead.svg" alt="Dead">
      <p>stickman-dead</p>
    </div>
    <div class="asset-card">
      <img src="assets/props/catapult.svg" alt="Catapult">
      <p>catapult</p>
    </div>
    <div class="asset-card">
      <img src="assets/props/sword.svg" alt="Sword">
      <p>sword</p>
    </div>
    <div class="asset-card">
      <img src="assets/props/shield.svg" alt="Shield">
      <p>shield</p>
    </div>
    <div class="asset-card">
      <img src="assets/props/arrow.svg" alt="Arrow">
      <p>arrow</p>
    </div>
    <div class="asset-card">
      <img src="assets/props/boulder.svg" alt="Boulder">
      <p>boulder</p>
    </div>
    <div class="asset-card">
      <img src="assets/props/fire.svg" alt="Fire">
      <p>fire</p>
    </div>
    <div class="asset-card">
      <img src="assets/props/debris-pile.svg" alt="Debris">
      <p>debris-pile</p>
    </div>
    <div class="asset-card">
      <img src="assets/props/crown.svg" alt="Crown">
      <p>crown</p>
    </div>
    <div class="asset-card">
      <img src="assets/props/tombstone.svg" alt="Tombstone">
      <p>tombstone</p>
    </div>
  </div>

  <footer>
    <p>UNLICENSE - Public Domain | <a href="https://github.com/corneliuscornelius">GitHub</a></p>
  </footer>

  <canvas id="death-of-life"></canvas>

  <script>
    /**
     * DEATH OF LIFE
     * A cellular automaton inspired by Conway's Game of Life,
     * but with stick figure death and gore.
     *
     * Rules:
     * - Living stick figures follow modified GoL rules
     * - Dying figures = surrounded by too many (overpopulation) or too few (loneliness)
     * - Dead figures leave blood pools and body parts
     * - Gore accumulates over time creating carnage layers
     */
    (function() {
      const canvas = document.getElementById('death-of-life');
      const ctx = canvas.getContext('2d');

      // Colors from palette
      const COLORS = {
        void: '#050508',
        night: '#0a0a10',
        bloodDark: '#1a0505',
        bloodRed: '#3d1515',
        bloodBright: '#5c1e1e',
        stick: '#1a1a1a',
        stickLight: '#2a2a2a',
        fireDark: '#8a2000',
        fireOrange: '#c03000',
        fireBright: '#e06000'
      };

      // Configuration
      const CELL_SIZE = 48;
      const FIGURE_SCALE = 0.7;
      const SPAWN_CHANCE = 0.08;
      const TICK_INTERVAL = 800;
      const MAX_GORE_LAYERS = 3;
      const BLOOD_SPREAD_CHANCE = 0.3;

      let cols, rows;
      let grid = [];
      let goreLayer = [];
      let lastTick = 0;

      // Cell states
      const STATE = {
        EMPTY: 0,
        ALIVE: 1,
        DYING: 2,
        DEAD: 3,
        GORE: 4
      };

      // Death types for variety
      const DEATH_TYPES = ['explode', 'collapse', 'dismember', 'impale'];

      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        cols = Math.ceil(canvas.width / CELL_SIZE);
        rows = Math.ceil(canvas.height / CELL_SIZE);

        // Preserve existing grid data if possible
        const oldGrid = grid;
        const oldGore = goreLayer;

        grid = [];
        goreLayer = [];

        for (let y = 0; y < rows; y++) {
          grid[y] = [];
          goreLayer[y] = [];
          for (let x = 0; x < cols; x++) {
            if (oldGrid[y] && oldGrid[y][x] !== undefined) {
              grid[y][x] = oldGrid[y][x];
              goreLayer[y][x] = oldGore[y] ? oldGore[y][x] : null;
            } else {
              grid[y][x] = { state: STATE.EMPTY, age: 0, deathType: null, deathFrame: 0 };
              goreLayer[y][x] = null;
            }
          }
        }
      }

      function init() {
        resize();
        // Seed initial population
        for (let y = 0; y < rows; y++) {
          for (let x = 0; x < cols; x++) {
            if (Math.random() < SPAWN_CHANCE) {
              grid[y][x] = { state: STATE.ALIVE, age: 0, deathType: null, deathFrame: 0 };
            }
          }
        }
        window.addEventListener('resize', resize);
        requestAnimationFrame(loop);
      }

      function countNeighbors(x, y) {
        let count = 0;
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue;
            const nx = (x + dx + cols) % cols;
            const ny = (y + dy + rows) % rows;
            if (grid[ny][nx].state === STATE.ALIVE) count++;
          }
        }
        return count;
      }

      function tick() {
        const newGrid = [];

        for (let y = 0; y < rows; y++) {
          newGrid[y] = [];
          for (let x = 0; x < cols; x++) {
            const cell = grid[y][x];
            const neighbors = countNeighbors(x, y);
            let newCell = { ...cell };

            switch (cell.state) {
              case STATE.ALIVE:
                newCell.age++;
                // Modified GoL rules - more death!
                if (neighbors < 2) {
                  // Loneliness death
                  newCell.state = STATE.DYING;
                  newCell.deathType = 'collapse';
                  newCell.deathFrame = 0;
                } else if (neighbors > 3) {
                  // Overpopulation death - violent
                  newCell.state = STATE.DYING;
                  newCell.deathType = DEATH_TYPES[Math.floor(Math.random() * DEATH_TYPES.length)];
                  newCell.deathFrame = 0;
                }
                break;

              case STATE.DYING:
                newCell.deathFrame++;
                if (newCell.deathFrame > 5) {
                  newCell.state = STATE.DEAD;
                  // Add gore to gore layer
                  addGore(x, y, newCell.deathType);
                }
                break;

              case STATE.DEAD:
                newCell.age++;
                // Bodies eventually become just gore
                if (newCell.age > 10) {
                  newCell.state = STATE.GORE;
                }
                break;

              case STATE.GORE:
                // Gore fades very slowly
                newCell.age++;
                if (newCell.age > 50 && Math.random() < 0.1) {
                  newCell.state = STATE.EMPTY;
                  newCell.age = 0;
                }
                break;

              case STATE.EMPTY:
                // Birth rule - exactly 3 neighbors
                if (neighbors === 3 && !goreLayer[y][x]) {
                  newCell.state = STATE.ALIVE;
                  newCell.age = 0;
                }
                // Random spawns at edges to keep things going
                if (Math.random() < 0.002) {
                  newCell.state = STATE.ALIVE;
                  newCell.age = 0;
                }
                break;
            }

            newGrid[y][x] = newCell;
          }
        }

        grid = newGrid;
        spreadBlood();
      }

      function addGore(x, y, deathType) {
        const gore = {
          type: deathType,
          bloodIntensity: Math.random() * 0.5 + 0.3,
          parts: [],
          created: Date.now()
        };

        // Add body parts based on death type
        if (deathType === 'explode') {
          gore.parts = ['head', 'arm', 'arm', 'leg', 'leg', 'torso'];
          gore.bloodIntensity = 0.8;
        } else if (deathType === 'dismember') {
          gore.parts = ['arm', 'leg'];
          gore.bloodIntensity = 0.6;
        } else if (deathType === 'impale') {
          gore.parts = ['torso'];
          gore.bloodIntensity = 0.5;
        }

        // Scatter parts to nearby cells
        gore.parts.forEach(part => {
          const offsetX = Math.floor(Math.random() * 3) - 1;
          const offsetY = Math.floor(Math.random() * 3) - 1;
          const nx = (x + offsetX + cols) % cols;
          const ny = (y + offsetY + rows) % rows;
          if (!goreLayer[ny][nx]) {
            goreLayer[ny][nx] = { type: 'part', part: part, rotation: Math.random() * Math.PI * 2 };
          }
        });

        goreLayer[y][x] = gore;
      }

      function spreadBlood() {
        for (let y = 0; y < rows; y++) {
          for (let x = 0; x < cols; x++) {
            const gore = goreLayer[y][x];
            if (gore && gore.bloodIntensity > 0.2 && Math.random() < BLOOD_SPREAD_CHANCE) {
              const dx = Math.floor(Math.random() * 3) - 1;
              const dy = Math.floor(Math.random() * 3) - 1;
              const nx = (x + dx + cols) % cols;
              const ny = (y + dy + rows) % rows;
              if (!goreLayer[ny][nx]) {
                goreLayer[ny][nx] = {
                  type: 'blood',
                  bloodIntensity: gore.bloodIntensity * 0.5
                };
              }
            }
          }
        }
      }

      // Drawing functions
      function drawStickFigure(x, y, scale, state, deathFrame, deathType) {
        const cx = x * CELL_SIZE + CELL_SIZE / 2;
        const cy = y * CELL_SIZE + CELL_SIZE / 2;
        const s = CELL_SIZE * FIGURE_SCALE * scale;

        ctx.save();
        ctx.translate(cx, cy);

        ctx.strokeStyle = COLORS.stick;
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';

        if (state === STATE.ALIVE) {
          drawAliveStickman(s);
        } else if (state === STATE.DYING) {
          drawDyingStickman(s, deathFrame, deathType);
        } else if (state === STATE.DEAD) {
          drawDeadStickman(s);
        }

        ctx.restore();
      }

      function drawAliveStickman(s) {
        const headR = s * 0.2;
        const torsoLen = s * 0.35;
        const limbLen = s * 0.25;

        // Head
        ctx.beginPath();
        ctx.arc(0, -s * 0.3, headR, 0, Math.PI * 2);
        ctx.stroke();

        // Eyes
        ctx.fillStyle = COLORS.stick;
        ctx.beginPath();
        ctx.arc(-headR * 0.3, -s * 0.32, 2, 0, Math.PI * 2);
        ctx.arc(headR * 0.3, -s * 0.32, 2, 0, Math.PI * 2);
        ctx.fill();

        // Torso
        ctx.beginPath();
        ctx.moveTo(0, -s * 0.1);
        ctx.lineTo(0, torsoLen - s * 0.1);
        ctx.stroke();

        // Arms
        ctx.beginPath();
        ctx.moveTo(-limbLen, 0);
        ctx.lineTo(limbLen, 0);
        ctx.stroke();

        // Legs
        ctx.beginPath();
        ctx.moveTo(0, torsoLen - s * 0.1);
        ctx.lineTo(-limbLen * 0.7, s * 0.4);
        ctx.moveTo(0, torsoLen - s * 0.1);
        ctx.lineTo(limbLen * 0.7, s * 0.4);
        ctx.stroke();
      }

      function drawDyingStickman(s, frame, deathType) {
        const progress = frame / 5;
        const headR = s * 0.2;

        ctx.globalAlpha = 1 - progress * 0.3;

        if (deathType === 'explode') {
          // Explosion - parts flying outward
          const spread = progress * s * 0.5;
          ctx.strokeStyle = COLORS.bloodBright;

          // Head flying up
          ctx.beginPath();
          ctx.arc(-spread * 0.5, -s * 0.3 - spread, headR * (1 - progress * 0.3), 0, Math.PI * 2);
          ctx.stroke();

          // Body parts scattered
          for (let i = 0; i < 5; i++) {
            const angle = (i / 5) * Math.PI * 2;
            const px = Math.cos(angle) * spread;
            const py = Math.sin(angle) * spread;
            ctx.beginPath();
            ctx.moveTo(px, py);
            ctx.lineTo(px + 5, py + 5);
            ctx.stroke();
          }

          // Blood splatter
          drawBloodSplatter(0, 0, s * progress);

        } else if (deathType === 'collapse') {
          // Collapse - crumpling down
          ctx.save();
          ctx.rotate(progress * Math.PI * 0.3);
          ctx.scale(1, 1 - progress * 0.5);
          drawAliveStickman(s);
          ctx.restore();

        } else if (deathType === 'dismember') {
          // Limbs coming off
          const offset = progress * s * 0.3;

          // Draw main body
          ctx.beginPath();
          ctx.arc(0, -s * 0.3, headR, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(0, -s * 0.1);
          ctx.lineTo(0, s * 0.25);
          ctx.stroke();

          // Detached arm
          ctx.strokeStyle = COLORS.bloodBright;
          ctx.beginPath();
          ctx.moveTo(-offset - s * 0.2, offset);
          ctx.lineTo(-offset - s * 0.1, offset + s * 0.1);
          ctx.stroke();

          // Blood from stump
          drawBloodSplatter(-s * 0.1, 0, offset * 0.5);

        } else if (deathType === 'impale') {
          // Impaled - hanging limp
          ctx.save();
          ctx.translate(0, progress * s * 0.1);

          // Head drooping
          ctx.beginPath();
          ctx.arc(headR * 0.3, -s * 0.25, headR, 0, Math.PI * 2);
          ctx.stroke();

          // X eyes
          ctx.beginPath();
          ctx.moveTo(headR * 0.1, -s * 0.27);
          ctx.lineTo(headR * 0.4, -s * 0.23);
          ctx.moveTo(headR * 0.4, -s * 0.27);
          ctx.lineTo(headR * 0.1, -s * 0.23);
          ctx.stroke();

          // Limp body
          ctx.beginPath();
          ctx.moveTo(0, -s * 0.05);
          ctx.lineTo(0, s * 0.3);
          ctx.stroke();

          // Blood drip
          ctx.fillStyle = COLORS.bloodBright;
          ctx.beginPath();
          ctx.ellipse(0, s * 0.35 + progress * 10, 3, 5, 0, 0, Math.PI * 2);
          ctx.fill();

          ctx.restore();
        }

        ctx.globalAlpha = 1;
      }

      function drawDeadStickman(s) {
        const headR = s * 0.15;

        ctx.strokeStyle = COLORS.stickLight;
        ctx.globalAlpha = 0.7;

        // Lying flat - rotated 90 degrees
        ctx.save();
        ctx.rotate(Math.PI / 2);

        // Head with X eyes
        ctx.beginPath();
        ctx.arc(-s * 0.3, 0, headR, 0, Math.PI * 2);
        ctx.stroke();

        // X eyes
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-s * 0.33, -3);
        ctx.lineTo(-s * 0.27, 3);
        ctx.moveTo(-s * 0.27, -3);
        ctx.lineTo(-s * 0.33, 3);
        ctx.stroke();
        ctx.lineWidth = 2;

        // Torso
        ctx.beginPath();
        ctx.moveTo(-s * 0.15, 0);
        ctx.lineTo(s * 0.15, 0);
        ctx.stroke();

        // Limp limbs
        ctx.beginPath();
        ctx.moveTo(-s * 0.05, 0);
        ctx.lineTo(-s * 0.1, s * 0.15);
        ctx.moveTo(0, 0);
        ctx.lineTo(s * 0.05, -s * 0.15);
        ctx.stroke();

        ctx.restore();
        ctx.globalAlpha = 1;
      }

      function drawBloodSplatter(cx, cy, radius) {
        ctx.fillStyle = COLORS.bloodRed;

        // Main pool
        ctx.beginPath();
        ctx.ellipse(cx, cy, radius, radius * 0.6, 0, 0, Math.PI * 2);
        ctx.fill();

        // Splatter droplets
        for (let i = 0; i < 5; i++) {
          const angle = Math.random() * Math.PI * 2;
          const dist = radius * (0.8 + Math.random() * 0.5);
          const dropX = cx + Math.cos(angle) * dist;
          const dropY = cy + Math.sin(angle) * dist;
          const dropR = 2 + Math.random() * 3;

          ctx.beginPath();
          ctx.arc(dropX, dropY, dropR, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      function drawGore(x, y) {
        const gore = goreLayer[y][x];
        if (!gore) return;

        const cx = x * CELL_SIZE + CELL_SIZE / 2;
        const cy = y * CELL_SIZE + CELL_SIZE / 2;

        ctx.save();
        ctx.translate(cx, cy);

        if (gore.type === 'blood' || gore.bloodIntensity) {
          // Blood pool
          ctx.fillStyle = COLORS.bloodDark;
          ctx.globalAlpha = Math.min(gore.bloodIntensity || 0.3, 0.6);
          ctx.beginPath();
          ctx.ellipse(0, 0, CELL_SIZE * 0.4, CELL_SIZE * 0.3, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;
        }

        if (gore.type === 'part') {
          // Draw body part
          ctx.rotate(gore.rotation);
          ctx.strokeStyle = COLORS.stickLight;
          ctx.lineWidth = 2;
          ctx.globalAlpha = 0.5;

          const partLen = CELL_SIZE * 0.2;

          if (gore.part === 'head') {
            ctx.beginPath();
            ctx.arc(0, 0, partLen * 0.6, 0, Math.PI * 2);
            ctx.stroke();
            // X eyes
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-3, -2);
            ctx.lineTo(3, 2);
            ctx.moveTo(3, -2);
            ctx.lineTo(-3, 2);
            ctx.stroke();
          } else if (gore.part === 'arm' || gore.part === 'leg') {
            ctx.beginPath();
            ctx.moveTo(-partLen, 0);
            ctx.lineTo(partLen, 0);
            ctx.stroke();
            // Joint
            ctx.beginPath();
            ctx.arc(partLen * 0.5, 0, 2, 0, Math.PI * 2);
            ctx.fill();
          } else if (gore.part === 'torso') {
            ctx.beginPath();
            ctx.moveTo(0, -partLen);
            ctx.lineTo(0, partLen);
            ctx.stroke();
          }

          ctx.globalAlpha = 1;
        }

        ctx.restore();
      }

      function draw() {
        // Clear with void color
        ctx.fillStyle = COLORS.void;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw subtle grid lines
        ctx.strokeStyle = COLORS.night;
        ctx.lineWidth = 0.5;
        for (let x = 0; x < cols; x++) {
          ctx.beginPath();
          ctx.moveTo(x * CELL_SIZE, 0);
          ctx.lineTo(x * CELL_SIZE, canvas.height);
          ctx.stroke();
        }
        for (let y = 0; y < rows; y++) {
          ctx.beginPath();
          ctx.moveTo(0, y * CELL_SIZE);
          ctx.lineTo(canvas.width, y * CELL_SIZE);
          ctx.stroke();
        }

        // Draw gore layer first (underneath)
        for (let y = 0; y < rows; y++) {
          for (let x = 0; x < cols; x++) {
            drawGore(x, y);
          }
        }

        // Draw cells
        for (let y = 0; y < rows; y++) {
          for (let x = 0; x < cols; x++) {
            const cell = grid[y][x];

            if (cell.state === STATE.ALIVE) {
              drawStickFigure(x, y, 1, STATE.ALIVE, 0, null);
            } else if (cell.state === STATE.DYING) {
              drawStickFigure(x, y, 1, STATE.DYING, cell.deathFrame, cell.deathType);
            } else if (cell.state === STATE.DEAD) {
              drawStickFigure(x, y, 0.8, STATE.DEAD, 0, null);
            }
          }
        }
      }

      function loop(timestamp) {
        // Tick the simulation
        if (timestamp - lastTick > TICK_INTERVAL) {
          tick();
          lastTick = timestamp;
        }

        draw();
        requestAnimationFrame(loop);
      }

      // Start when DOM is ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }
    })();
  </script>
</body>
</html>
